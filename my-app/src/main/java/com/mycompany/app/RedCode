//OGC from Availability_Bush + same for Availability_Waterloo

//        void v_update_Bush_to_Zero(int itime) throws SQLException {
//            String s=String.valueOf(itime);
//            String sql = "UPDATE CURICULUM.availability_halls_bush_house " +
//                    "     SET available = 0 " +
//                    "     WHERE hour = " + s;
//
//
//            PreparedStatement preparedStmt = connection.prepareStatement(sql);
//            preparedStmt.execute();
//            preparedStmt.close();
//        }
//
//        void v_update_Bush_to_One(int itime) throws SQLException {
//            String s=String.valueOf(itime);
//            String sql = "UPDATE CURICULUM.availability_halls_bush_house " +
//                "     SET available = 1 " +
//                "     WHERE hour = " + s;
//
//
//            PreparedStatement preparedStmt = connection.prepareStatement(sql);
//            preparedStmt.execute();
//            preparedStmt.close();
//        }
//
//        boolean b_checkAvailableAt(int itime) throws SQLException {
//            String s=String.valueOf(itime);
//            Statement stmt = connection.createStatement();
//            String sql = "SELECT available " +
//                    "     FROM curiculum.timeslots " +
//                    "     WHERE  hour = " + s;
//
//
//            ResultSet rs = stmt.executeQuery(sql);
//            stmt.close();
//
//            if(rs.getInt("available") == 1){
//                rs.close();
//                return true;
//            }
//            else{ rs.close(); return  false; }
//
//        }




    //OGC from Greedy Algorithm
//
//    private void vgenerateTableAvailabilityOfHalls()throws SQLException{
//        //1.start by assigning the lectures in the timeslots available from the week days
//        //2.assign the students to the lectures following the simple rules of the hard constraints
//        //3.
//        // find a suitable layout of tutorials and lectures . Only Lectures first. since tutorials are not yet inserted
//        int iCounter = 0;
//        ArrayList<String> mylist = new ArrayList<>();
//        mylist.add("Monday");
//        mylist.add("Tuesday");
//        mylist.add("Wednesday");
//        mylist.add("Thursday");
//        mylist.add("Friday");
//        String sql22 = "SELECT abreviation,hours_twoweeks FROM s_courses WHERE hours_twoweeks != 0";
//        Statement statement = connection.createStatement();
//        ResultSet resSet = statement.executeQuery(sql22);
//        int index = 0;
//        while(resSet.next()){
//            String abrev = resSet.getString("abreviation");
//            int iHours = resSet.getInt("hours_twoweeks")/2;
//            initial.add(new Duplet(abrev,iHours));
//            initial.add(new Duplet(abrev,iHours));
//            System.out.println(initial.get(index));
//            index++;
//            index++;
//        }
//        int sum = 0;
//        for(int i = 0; i < initial.size(); i++){
//            sum += initial.get(i).getiHours();
//        }
//        System.out.println("Sum:" + sum);
//        //create a table of assigned lectures:
//        String sql99 = "DROP TABLE IF EXISTS assigned_lects";
//        String sql33 = "DROP TABLE IF EXISTS halls_availability_tweeks";
//        String sql11 =
//                "CREATE TABLE assigned_lects(" +
//                        "ABBREV VARCHAR(10), " +
//                        "HOURS INT(2), " +
//                        "HALL VARCHAR(30)," +
//                        "DAYTIME INT(4))";
//        String sql88 =
//                "CREATE TABLE halls_availability_tweeks(" +
//                        "AVAILABLE INT(1)," +
//                        "HALL VARCHAR(10)," +
//                        "HOUR INT(2), " +
//                        "DAY VARCHAR(10))";
//        String sql44 = "SELECT AVAILABLE, HALL, HOUR FROM availability_halls_bush_house";
//        String sql55 = "SELECT AVAILABLE, HALL, HOUR FROM availability_halls_waterloo";
//        String sql66 = "INSERT INTO halls_availability_tweeks VALUES( ?,?,?,? )";
//
//
//        statement.executeUpdate(sql99);
//        statement.executeUpdate(sql11);
//        statement.executeUpdate(sql33);
//        statement.executeUpdate(sql88);
//
//        ResultSet rst1 = statement.executeQuery(sql44);
//        PreparedStatement prst = connection.prepareStatement(sql66);
//        while(!mylist.isEmpty()){
//            //iCounter++;
//            while(rst1.next()){
//                prst.setInt(1, rst1.getInt("AVAILABLE"));
//                prst.setString(2, rst1.getString("HALL"));
//                prst.setInt(3, rst1.getInt("HOUR"));
//                prst.setString(4, mylist.get(iCounter));
//                prst.executeUpdate();
//            }
//            //System.out.println("Removed" + mylist.get(iCounter));
//            mylist.remove(iCounter);
//            rst1.beforeFirst();
//        }
//
//    }

    //


/*
    private Double d_TotalHoursOfHallsAvailable_Bush_House(String sStardDate, String sEndDate) throws ParseException, SQLException {

            double dHours = 0.0;
            Date date1 = new SimpleDateFormat("dd-MMM-yyyy").parse(sStardDate);
            Date date2 = new SimpleDateFormat("dd-MMM-yyyy").parse(sEndDate);
            String sql34 = "";
            PreparedStatement prst;
            if(date1.getMonth() != date2.getMonth() && date2.getMonth() - date1.getMonth() == 1){
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? " +
                        " UNION " +
                        " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ? ";
                prst = connection.prepareStatement(sql34);
                prst.setInt(1, date1.getMonth());
                prst.setInt(2, date1.getDate());
                prst.setInt(3, date2.getMonth());
                prst.setInt(4,date2.getDate());
            }
            else {
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? UNION";
                int iCounter = 1;
                int iSecondCounter = 0;

                for (int i = date1.getMonth() + 1; i < date2.getMonth(); i++) {
                    sql34 += " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? UNION ";
                    iSecondCounter++;
                }
                sql34 += " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ?";


                prst = connection.prepareStatement(sql34);
                prst.setInt(iCounter, date1.getMonth());
                prst.setInt(++iCounter, date1.getDate());
                for (int i = 1; i < iSecondCounter + 1; i++) {
                    prst.setInt(++iCounter, date2.getMonth() - i);
                }
                prst.setInt(++iCounter, date2.getMonth()); //check this
                prst.setInt(++iCounter, date2.getDate());    //check this

            }
            ResultSet rst = prst.executeQuery();
            double dSum = 0.0;
            while (rst.next()){
                dSum += rst.getInt(1);
            }


            return dSum/2;
        }
        private Double d_TotalHoursOfHallsAvailable_Waterloo(String sStardDate, String sEndDate) throws ParseException, SQLException {
            double dHours = 0.0;
            Date date1 = new SimpleDateFormat("dd-MMM-yyyy").parse(sStardDate);
            Date date2 = new SimpleDateFormat("dd-MMM-yyyy").parse(sEndDate);
            String sql34 = "";
            PreparedStatement prst;
            if(date1.getMonth() != date2.getMonth() && date2.getMonth() - date1.getMonth() == 1){
                sql34 = " SELECT * FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? " +
                        " UNION " +
                        " SELECT * FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ? ";
                prst = connection.prepareStatement(sql34);
                prst.setInt(1, date1.getMonth());
                prst.setInt(2, date1.getDate());
                prst.setInt(3, date2.getMonth());
                prst.setInt(4,date2.getDate());
            }
            else {
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? UNION";
                int iCounter = 1;
                int iSecondCounter = 0;

                for (int i = date1.getMonth() + 1; i < date2.getMonth(); i++) {
                    sql34 += " SELECT COUNT(*) FROM two_weeks_availability_waterloo WHERE AVAILABLE = 1 AND MONTH = ? UNION ";
                    iSecondCounter++;
                }
                sql34 += " SELECT COUNT(*) FROM two_weeks_availability_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ?";


                prst = connection.prepareStatement(sql34);
                prst.setInt(iCounter, date1.getMonth());
                prst.setInt(++iCounter, date1.getDate());
                for (int i = 1; i < iSecondCounter + 1; i++) {
                    prst.setInt(++iCounter, date2.getMonth() - i);
                }
                prst.setInt(++iCounter, date2.getMonth()); //check this
                prst.setInt(++iCounter, date2.getDate());    //check this

            }
            ResultSet rst = prst.executeQuery();
            double dSum = 0.0;
            while (rst.next()){
                dSum += rst.getInt(1);
            }


            return dSum/2;
        }
        private Double d_TotalHoursOfHallsAvailable_Waterloo_SpecificHall(String sName, String sStardDate, String sEndDate) throws ParseException, SQLException {
            double dHours = 0.0;
            Date date1 = new SimpleDateFormat("dd-MMM-yyyy").parse(sStardDate);
            Date date2 = new SimpleDateFormat("dd-MMM-yyyy").parse(sEndDate);
            String sql34 = "";
            PreparedStatement prst;
            if(date1.getMonth() != date2.getMonth() && date2.getMonth() - date1.getMonth() == 1){
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? AND HALL = ?" +
                        " UNION " +
                        " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ? AND HALL = ?";
                prst = connection.prepareStatement(sql34);
                prst.setInt(1, date1.getMonth());
                prst.setInt(2, date1.getDate());
                prst.setString(3, sName);
                prst.setInt(4, date2.getMonth());
                prst.setInt(5,date2.getDate());
                prst.setString(6, sName);
            }
            else {
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? AND HALL = ? UNION";
                int iCounter = 1;
                int iSecondCounter = 0;

                for (int i = date1.getMonth() + 1; i < date2.getMonth(); i++) {
                    sql34 += " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND HALL = ? UNION ";
                    iSecondCounter++;
                }
                sql34 += " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ? AND HALL = ? ";


                prst = connection.prepareStatement(sql34);
                prst.setInt(iCounter, date1.getMonth());
                prst.setInt(++iCounter, date1.getDate());
                prst.setString(++iCounter, sName);
                for (int i = 1; i < iSecondCounter + 1; i++) {
                    prst.setInt(++iCounter, date2.getMonth() - i);
                    prst.setString(++iCounter, sName);
                }
                prst.setInt(++iCounter, date2.getMonth()); //check this
                prst.setInt(++iCounter, date2.getDate());    //check this
                prst.setString(++iCounter, sName);
            }
            ResultSet rst = prst.executeQuery();
            double dSum = 0.0;
            while (rst.next()){
                dSum += rst.getInt(1);
            }


            return dSum/2;
        }

        private Double d_TotalHoursOfHallsAvailable(String sStardDate, String sEndDate) throws ParseException, SQLException {
            return d_TotalHoursOfHallsAvailable_Bush_House(sStardDate,sEndDate) + d_TotalHoursOfHallsAvailable_Waterloo(sStardDate, sEndDate);
        }
        private int d_AllHallsCapacity() throws  SQLException{
            int iResult = 0;
            String sql99 = "SELECT SUM(CAPACITY) FROM FACILITIES";
            PreparedStatement prst = connection.prepareStatement(sql99);
            ResultSet rst = prst.executeQuery();
            while(rst.next()){
                iResult = rst.getInt(1);
            }
            return iResult;
        }
        private int d_SpicificHallCapacity(String sName) throws  SQLException{
            int iResult = 0;
            String sql99 = "SELECT CAPACITY FROM FACILITIES WHERE inside_code = ?";
            PreparedStatement prst = connection.prepareStatement(sql99);
            prst.setString(1, sName);
            ResultSet rst = prst.executeQuery();
            while(rst.next()){
                iResult = rst.getInt(1);
            }
            return iResult;
        }
        /**/
        private double d_capacityPerHour_Waterloo_SpecificHall(String sName,String sStartDate,String sEndDate) throws SQLException, ParseException {
            double iResult = d_SpicificHallCapacity(sName);
            double sHours = d_TotalHoursOfHallsAvailable_Waterloo_SpecificHall(sName, sStartDate, sEndDate);

            return sHours*iResult / 55;
        }
*/



//from inserter_lectures_assigned method finalTable
while(iCounter != 80){
            iCounter++;
            //find the attendance where values are too low = below the min
            if(initial_values.size() != 0) {
                if (initial_values_attendance.get(0) < min) {
                    for (int j = 0; j < values.size(); j++) {
                        //too few
                        if (values.get(j).getiAttending() > min && values.get(j).getiAttending() + initial_values_attendance.get(0) < max) {
                            //suitable solution found
                            iStudentsReassigned += initial_values_attendance.get(0);
                            values.set(j, new TwoInts(values.get(j).getiCode(), values.get(j).getiAttending() + initial_values_attendance.get(0)));
//something I noticed about this method is that it is going to pick the first available course every time,
                            initial_values_attendance.remove(0);
                            initial_values.remove(0);
                            iAssigned = 1;
                            String sql77 = "UPDATE students_lectures SET lecture_code = " + Integer.toString(values.get(j).getiCode()) + " WHERE lecture_code = " + Integer.toString(initial_values.get(0));
                            Statement statement2 = connection.createStatement();
                            statement2.executeUpdate(sql77);
                            break; // before breaking this would need updating
                        } else {
                            //no suitable courses found: how do we proceed?? -> assign to the next available course in the current list

                        }
                    }
                    if (iAssigned == 0) {
                        initial_values_attendance.add(initial_values_attendance.get(0));
                        initial_values_attendance.remove(0);
                        initial_values.add(initial_values.get(0));
                        initial_values.remove(0);
                    }
                    iAssigned = 0;
                }
            }
            else if (initial_values.size() != 0 && initial_values_attendance.get(0) > max){

            }
            else{
                if(initial_values.size() != 0 && initial_values_attendance.get(0) < min ){
                    continue;
                }else if(initial_values.size() != 0 && initial_values_attendance.get(0) > max ){
                    //add to values array

                }
                else {
                    continue;
                }
            }

        }
////


///GREEDY ALGORITHM:


    public int generateGreedySolution(String sTable,String sTableStudents, int min, int max, ArrayList<String> preferreddays) throws SQLException, ParseException, CloneNotSupportedException, IOException {


        this.sCoursesTable = sTable;
        this.sStudentsTable = sTableStudents;
        this.iLocalMin = min;
        this.iLocalMax = max;
        this.prefdDays= preferreddays;

        Week_Timetable week_timetableont = myTimetable(7);

        ArrayList <Duplet> myarr = lecturesToBeAssigned2( getTwoInts() ,1, sTable);  //this ARRAY contains all the info for the lectures
        ArrayList <Duplet> weekOne = new ArrayList<>();
        ArrayList <Duplet> weekTwo = new ArrayList<>();

        for (int i = 0; i < myarr.size(); i++) {
                myarr.get(i).setPreferredDays(new PreferredDays(preferreddays));
        }

/*            for (int i = 0; i < myarr.size(); i++) {
//                myarr.get(i).setPreferredDays(o_getPreferencesStudents(myarr.get(i).getsLect(), 1, 5));
//                myarr.get(i).setsTeachersPreference(s_getLecturersChoice(myarr.get(i).getsLect()));
//            }
*/
        Collections.sort(myarr);                        //sort my array to start searching for the lectures with least students (asc order)

        for(int i = 0; i < myarr.size(); i++){
            if(i % 2 == 0){ weekOne.add(myarr.get(i));}
            else{weekTwo.add(myarr.get(i));}
        }


         //week_timetableont.setLectures(myarr); //ONLY FOR TESTING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         week_timetableont.setLectures(weekOne);

        weekOne = setConstraints(weekOne);
        weekTwo = setConstraints(weekTwo);              //I could clone the weekOne here instead
        //myarr = setConstraints(myarr); //ONLY FOR TESTING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        //addDaysToLastMostRecentDay(7);
        ArrayList<Hall> halls = hallsAvailability_forlectures(week_timetableont.getsStartDay(), week_timetableont.getsEndDay());//will have to change this to take the parameters of the week, suttle change
        week_timetableont.setHalls(halls);

        //Collections.sort(halls);


        //assign lectures to Halls here :
        // i need to find a way to make the algorithm tell if there is no solution
        // checkAtEachStepTheConstraints
        //
        //week_timetableont.getLectures().forEach((n) -> System.out.print(n));

        int iCounter = 0;
        while (iCounter != 2000){

             int iStudents = 0;
            if(week_timetableont.getLectures().size() != 0 && week_timetableont.getHalls().size() != 0) {
                iStudents = week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending();
            }
            else{ iCounter++; continue;}

            week_timetableont = recursion_for_lectures(week_timetableont,week_timetableont.getHalls(), week_timetableont.getLectures(),week_timetableont.getAssignedLectures(),
                    week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending() ,week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending(),
                    1,0, 1);
            iCounter++;

            }


        ///lectures correspond to the tutorials with the exception that tutorials are shorter
            //week_timetableont.updateDependentOnTutorials();
        ///

        //week_timetableont.getHalls().forEach((n)->System.out.println(n));
        System.out.println("Not Assigned Lectures:");
        System.out.println(week_timetableont.getLectures());

        for(int i = 0; i < week_timetableont.getWeekTimet().size();i++){
            Collections.sort(week_timetableont.getWeekTimet().get(i).getoDslot2());
        }
        week_timetableont.v_print();

        this.week_timetable_ont = week_timetableont;


//        putInTableAssigned(week_timetableont.getAssignedLectures(), 0);
       // generateTimeTables_firstYear(schedule, sTableStudents);


            if(week_timetableont.getLectures().size() == 0 ){
                // solution found
                return 1;
            }
            else{
                return 0;


                //opt for running the algorithm again, maybe a bit differently or choose to run another algorithm
            }

        /**/


    }



    public int generateGreedySolution2(String sTable, String sTableStudents, int min, int max, ArrayList<String> preferreddays, Week_Timetable week_timetableont) throws SQLException, ParseException, CloneNotSupportedException, IOException {


        ArrayList<Hall> halls = hallsAvailability_forlectures(week_timetableont.getsStartDay(), week_timetableont.getsEndDay());
        //Collections.sort(halls);
        //week_timetableont.setHalls(halls);
        for (int i = 0; i < week_timetableont.getLectures().size(); i++) {
            ArrayList<String> prefs =  new ArrayList<>();
            if(!week_timetableont.getLectures().get(i).getsDayOfWeek().isEmpty()) {
                prefs.add(week_timetableont.getLectures().get(i).getsDayOfWeek());
                week_timetableont.getLectures().get(i).setPreferredDays(new PreferredDays(prefs));
            }
            else{
                week_timetableont.getLectures().get(i).setPreferredDays(new PreferredDays(preferreddays));
            }
        }

        int iCounter = 0;
        while (iCounter != 2000){

            int iStudents = 0;
            if(week_timetableont.getLectures().size() != 0 && week_timetableont.getHalls().size() != 0) {
                iStudents = week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending();
            }
            else{ iCounter++; continue;}

            week_timetableont = recursion_for_lectures(week_timetableont,week_timetableont.getHalls(), week_timetableont.getLectures(),week_timetableont.getAssignedLectures(),
                    week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending() ,week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending(),
                    1,0, 1);
            iCounter++;

        }

        System.out.println("Not Assigned Lectures:");
        System.out.println(week_timetableont.getLectures());

        for(int i = 0; i < week_timetableont.getWeekTimet().size();i++){
            Collections.sort(week_timetableont.getWeekTimet().get(i).getoDslot2());
        }
        week_timetableont.v_print();

        this.week_timetable_spare = week_timetableont;

        if(week_timetableont.getLectures().size() == 0 ){
            return 1;
        }
        else{
            return 0;
        }

        /**/


    }



///////////


//HC algorithm:


                            for(int iHourIterator = 0; iHourIterator < hours.size(); iHourIterator++) {
                                if (!tempAssign.isEmpty() && hours.get(iHourIterator).getiHour() == coupledData.getiHour()) { students.addAll( findInDataByHour(tempAssign, hours.get(iHourIterator).getiHour() )); }
                            }
                            if(students.size() >= halls.getiCapacity()/2){
                                if(tempAssign.size() - students.size() <= halls.getiCapacity()/2){
                                    students = (ArrayList<DataSetStudents>) tempAssign.clone();
                                }
                                else{
                                    if(students.size() > halls.getiCapacity()){
                                        students = randomlyRemoveFromArray(students,halls.getiCapacity());
                                    }
                                }
                            }else{
                                if(students.isEmpty()){
                                    for(int iHourIterator = 0; iHourIterator < hours.size(); iHourIterator++) {
                                        if (!tempAssign.isEmpty()) {
                                            if(students.size() < halls.getiCapacity()/2) students.addAll(findInDataByHour(tempAssign, hours.get(iHourIterator).getiHour()));
                                        }
                                        if (students.size() >= halls.getiCapacity() / 2) {
                                            if (tempAssign.size() - students.size() <= halls.getiCapacity()) {
                                                students = (ArrayList<DataSetStudents>) tempAssign.clone();
                                                break;
                                            }
                                        }
                                    }
                                    if(tempAssign.size() - students.size() <= halls.getiCapacity()/2){
                                        students = (ArrayList<DataSetStudents>) tempAssign.clone();
                                    }
                                }
                                else{
                                    for(int iHourIterator = 0; iHourIterator < hours.size(); iHourIterator++) {
                                        // if (!tempAssign.isEmpty()) { students.addAll( findInDataByHour(tempAssign, hours.get(iHourIterator).getiHour() )); }
                                    }
                                }

                            }
/// END HC


///APP main:

HillClimbing hillClimbing = new HillClimbing(connection);
        hillClimbing.getGrdAlg().setTwoInts(generator.getLectureEvents());
        hillClimbing.getGrdAlg().generateGreedySolution_TwoWeeks("courses", "students", 5, 21,days, "", 0);
        hillClimbing.setTIMETABLEONT_GLOBAL(hillClimbing.getGrdAlg().getWeek_timetable_ont());
        hillClimbing.setTIMETABLETWO_GLOBAL(hillClimbing.getGrdAlg().getWeek_timetable_spare());
        hillClimbing.generateHCSolution(0.9, 3, 5);


//        List<int[]> combinations = generate(29, 20);
//        for (int[] combination : combinations) {
//            //System.out.println(Arrays.toString(combination));
//        }
//        System.out.printf("generated %d combinations of %d items from %d ", combinations.size(), 2, 5);

    private static void helper(List<int[]> combinations, int data[], int start, int end, int index) {
        if (index == data.length) {
            int[] combination = data.clone();
            combinations.add(combination);
        } else if (start <= end) {
            data[index] = start;
            helper(combinations, data, start + 1, end, index + 1);
            helper(combinations, data, start + 1, end, index);
        }
    }


    public static List<int[]> generate(int n, int r) {
        List<int[]> combinations = new ArrayList<>();
        helper(combinations, new int[r], 0, n-1, 0);
        return combinations;
    }



///////// FROM HillClimbing


    public void algorithmAssigning_year2(Week_Timetable timetable, int iPredefinedIterations, int minNumForTutorials,int maxNumForTutorials, int iYearOfStudy) throws SQLException, CloneNotSupportedException, ParseException {


        int iLectureAssignedSuccessfully  = 0;
        ArrayList<DataSetStudents> toAssign = getHCData(iYearOfStudy);
        ArrayList<DataSetStudents> tempAssign =  new ArrayList<>();         // I need the list of duplets plus all their details for week2s
        ArrayList<Duplet> sgts = new ArrayList<>();

        String courseAbrev = "";

        if(iYearOfStudy == 1){courseAbrev = "4CCS";}
        if(iYearOfStudy == 2){courseAbrev = "5CCS";}
        if(iYearOfStudy == 3){courseAbrev = "6CCS";}



        for(Duplet event : timetable.getSgt()){
            if(event.getsLect().startsWith(courseAbrev)){
                sgts.add(event);
            }
        }

        HashMap<String, ArrayList<Duplet>> sorterOfSGTs = new HashMap<>();

        for(Duplet event : sgts){
            if(event.getsDayOfWeek().equals("Monday")){
                if(sorterOfSGTs.get("Monday") == null){
                    sorterOfSGTs.put("Monday", new ArrayList<>());
                    sorterOfSGTs.get("Monday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Monday").add(event);
                    continue;
                }
            }
            if(event.getsDayOfWeek().equals("Tuesday")){
                if(sorterOfSGTs.get("Tuesday") == null){
                    sorterOfSGTs.put("Tuesday", new ArrayList<>());
                    sorterOfSGTs.get("Tuesday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Tuesday").add(event);
                    continue;
                }
            }
            if(event.getsDayOfWeek().equals("Wednesday")){
                if(sorterOfSGTs.get("Wednesday") == null){
                    sorterOfSGTs.put("Wednesday", new ArrayList<>());
                    sorterOfSGTs.get("Wednesday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Wednesday").add(event);
                    continue;
                }
            }
            if(event.getsDayOfWeek().equals("Thursday")){
                if(sorterOfSGTs.get("Thursday") == null){
                    sorterOfSGTs.put("Thursday", new ArrayList<>());
                    sorterOfSGTs.get("Thursday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Thursday").add(event);
                    continue;
                }
            }
            if(event.getsDayOfWeek().equals("Friday")){
                if(sorterOfSGTs.get("Friday") == null){
                    sorterOfSGTs.put("Friday", new ArrayList<>());
                    sorterOfSGTs.get("Friday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Friday").add(event);
                    continue;
                }
            }
        }

        ArrayList<Duplet> dupletArrayListSorted = new ArrayList<>();
        if(sorterOfSGTs.get("Friday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Friday"));}
        if(sorterOfSGTs.get("Thursday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Thursday"));}
        if(sorterOfSGTs.get("Wednesday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Wednesday"));}
        if(sorterOfSGTs.get("Tuesday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Tuesday"));}
        if(sorterOfSGTs.get("Monday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Monday"));}


        sgts = (ArrayList<Duplet>) dupletArrayListSorted.clone();
        dupletArrayListSorted = null;
        sorterOfSGTs = null;

        for(Duplet event : sgts){ //start assigning each event
            ArrayList<Integer> codesOfLectures = new ArrayList<>();             //I NEED TO FILL THIS ARRAY AS THOSE ARE THE DEPENDENCIES, each event holds the dependencies of the lecture,
            // currently due to the large number of students and variations, each event holds as dependencies all the other lectures in the same year, so I could use this to check for
            Duplet temp = (Duplet) event.clone();
            SGT temp_sgt = new SGT();
            tempAssign = findInData(toAssign, event.getsLect());                    //those are the students to be assigned

            for(int numIterations = 0; numIterations < iPredefinedIterations; numIterations++) {

                int iHallFound = 0;
                temp_sgt = new SGT();
                temp_sgt.setiCode(temp.getiCode());
                temp_sgt.setiHours(1);
                temp_sgt.setsLect(temp.getsLect());

                for (CoupledData heuristicsData : event.getPreferredDays().getHeuristics()) {

                    if (tempAssign.size() == 0) break;
                    if (iHallFound == 1) break;                                                 //will beginfrom the start every time a suitable hall is found for the current iteration
                    String sDayIteration = heuristicsData.getsDay();
                    ArrayList<DataSetStudents> students = findInDataByDay(tempAssign, event.getsLect(), sDayIteration);


                    for (Hall halls : timetable.getHalls()) {                     //test for each day the availability if not available proceed to assigning toa free slot,if there are available

                        if(students.isEmpty()) break;
                        if(students.size() < minNumForTutorials) break;
                        if(iHallFound == 1) break;
                        if(students.isEmpty()) break;       //add if hall is the last hall and not found then break;

                        if (students.size() > halls.getiCapacity()) {

                            if (students.size() == halls.getiCapacity() && availableForFiltering(students.size(), halls.getiCapacity()) < 20030010L) { //NEEDS TO BE REVIEWED// SO THAT NO MEMORY OVERFLOW WOULD OCCUR//FILTER ADDED HERE TO CHOSE WHO OF THE STUDENTS WILL GET ASSIGNED, ONLY WORKS ON SPECIFIC SIZES BEFORE EXPONENTIAL GROWTH

                                int st2 = 0;
                                for (int st = 0; st < students.size(); st++) {
                                    st2 = st;
                                    students.get(st).setNumberforCombinations(st);              //gives each datasetstudent object a unique number
                                }

                                ArrayList<DataSetStudents> filtered = new ArrayList<>();
                                // ArrayList<DataSetStudents[]> filtered2 = generate_myGenerate(st2 + 1, 20, students);        //find the combination of students suitable for my needs(lowest/highest number of lecture code dependencies)
                                ArrayList<Integer> lowestFound = new ArrayList<>();
                                ArrayList<Integer> iteration = new ArrayList<>();

//                            for (int k = 0; k < filtered2.size(); k++) {           //traverse the combinations
//                                ArrayList<DataSetStudents> combination = new ArrayList<>(Arrays.asList(filtered2.get(k)));
//
//                                iteration = lectureCodesOfStudents(combination, toAssign);
//                                if (iteration.size() < lowestFound.size()) {
//                                    lowestFound = iteration;
//                                    filtered = combination;
//                                }//after finding the combination with the lowest or highest number of courses could be tested for both, then assign the students and move them from the global data array to the assigned
//                            }

                                //assign them now to this course:
                                //1. find suitable day
                                //2. find most popular choices of hour among this group
                                //3.


                            } else {//randomly pick among the students to reach the hall's capacity
                                students = randomlyRemoveFromArray(students, halls.getiCapacity());
                            }
                        }
                        else {
                            if(students.size() < minNumForTutorials){
                                students.addAll(randomStudents(tempAssign, minNumForTutorials - students.size()));
                            }//do something else here instead, this check is already at the start of halls iteration
                        }


                        ArrayList<Timeslot> notAvailable = notavailableTime_specificDay(students, timetable, temp_sgt);
                        //ArrayList<Timeslot> notAvailable_onlyLectures = notavailableTime_specificDay_onlyLectures(students, timetable);               //ONLY FOR TESTING

                        temp_sgt.setNotAvailableSlots(notAvailable);

                        ArrayList<Timeslot> iTimes = halls.findAvailableSlot_PreferredDay_sgt_remastered(900, 1.0, heuristicsData.getsDay(), event, temp_sgt.getNotAvailableSlots());

                        //ArrayList<Timeslot> iTimes_Lectures = halls.findAvailableSlot_PreferredDay_sgt_remastered(900, 1.0, heuristicsData.getsDay(), event, notAvailable_onlyLectures);      //ONLY FOR TESTING
                        //temp_sgt.getAvailableSlots().addAll(iTimes);

                        temp_sgt.setAvailableSlots(iTimes);

                        //temp_sgt.setAvailableSlots_noDependencies(iTimes_Lectures);         //only for testing, changes every time the hall is changed, so not very useful

                        ArrayList<CoupledData> times_coupledData = heuristics_sgt_preferredHours(event, DSCALE_GLOBAL, sDayIteration);
                        for (CoupledData coupledData : times_coupledData) {
                            int iHourFound = i_prefferedTime_byDay_check(temp_sgt, sDayIteration, coupledData.getiHour(), halls.getsAbbrev());
//                                int iHourFound = halls.checkAvailability(sDayIteration, coupledData.getiHour(), 1.0);
                            if(iHallFound == 1) break;

                            if (iHourFound != 0) {
                                int iFinalCheck = halls.checkAvailability(sDayIteration, iHourFound, 1.0);

                                if (iFinalCheck != 0) {

                                    int iAddCode = halls.getiAdditionalCode();
                                    for (int t = 0; t < timetable.getHalls().size(); t++) {
                                        if (timetable.getHalls().get(t).getiAdditionalCode() == iAddCode) {
                                            timetable.getHalls().get(t).setAvToZero(iHourFound, (int) (iHourFound + 1 * 100), sDayIteration);   // ONLY TRIES THE FIRST CHOICE OF HEURISTICS
                                            updateAvailabilitySlotsSGT(temp_sgt, sDayIteration, halls.getsAbbrev(),iHourFound);

                                            for (int f = 0; f < timetable.getWeekTimet().size(); f++) {                 //add to the Day log, for printing purposes + check
                                                if (timetable.getWeekTimet().get(f).getSname().toLowerCase(Locale.ROOT).equals(sDayIteration.toLowerCase(Locale.ROOT))) {
                                                    timetable.getWeekTimet().get(f).v_assignEvent(iHourFound, 1, halls.getsAbbrev(), temp.getsLect(), "event");
                                                    int iDate = timetable.getWeekTimet().get(f).getiDate();
                                                    int iMonth = timetable.getWeekTimet().get(f).getiMonth();//+1
                                                    int iYear = timetable.getWeekTimet().get(f).getiYear();//+1900
                                                    iHallFound = 1;
                                                    temp_sgt.setDayAssigned(sDayIteration);//this line is wrong
                                                    temp_sgt.setiHourScheduled(iHourFound);
                                                    temp_sgt.setiDayScheduled(iDate);
                                                    temp_sgt.setiMonthScheduled(iMonth + 1);
                                                    temp_sgt.setiYearScheduled(iYear); // + 1900
                                                    temp_sgt.setsDayOfWeek(sDayIteration);
                                                    temp_sgt.setsLectureHall(timetable.getHalls().get(t).getsAbbrev());
                                                    temp_sgt.setiSizeOfHall(halls.getiCapacity());
                                                    break;
                                                }
                                            }
                                        }
                                    }


                                    // change this to the size of the array assigning which is of course == capacity of the hall
                                    for (int stdItr = 0; stdItr < students.size(); stdItr++) {
                                        //increase the number of attending students for this sgt
                                        tempAssign.remove(students.get(stdItr));
                                        temp_sgt.setiNumberOfStudentsAttending(stdItr + 1);
                                        temp_sgt.addToCodesOfStudentsAssigned(students.get(stdItr).getKings_id());
                                        this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(stdItr).getKings_id()).addToCourses(temp_sgt);
                                        this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(stdItr).getKings_id()).increaseAssignedCoursesNumber();
                                        this.ASSIGNED_STUDENTS_GLOBAL.put((students.get(stdItr).getKings_id()), this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(stdItr).getKings_id()));

                                    }

                                    //carry on assigning people until all people are assigned, if there is
                                    //no available spot for the rest of the people/ all of them then
                                    //try at random, and if again, then add to the unsuccessfully assigned lectures

                                    //now remove them from the data so that they are not retrieved again
                                    updateAvailailitySlotsSGT_AllEvents(temp_sgt);
                                    this.ASSIGNED_SGTS_CURRENTWEEK_GLOBAL.add(temp_sgt);//or a clone, this is inside the first for(!)

                                }

                            }
                        }


                    }//END OF HALLS
                }//END OF COUPLED DATA
            } // END OF FOR LOOP

            if(!tempAssign.isEmpty()){
                //students whose preferences for day were not satisfiable would fall into this if statement
                //since there are only a number of days are alowed for a sgt, depending on the lecture, algoithm
                //will still assign to those days

                int iPredefinedIterations2 = 2*iPredefinedIterations;                   //CHANGE THIS LINE OF CODE
                ArrayList<DataSetStudents> students = new ArrayList<>();

                for(int numIterations = 0; numIterations < iPredefinedIterations2; numIterations++) {

                    temp_sgt = new SGT();
                    temp_sgt.setiCode(temp.getiCode());
                    temp_sgt.setiHours(1);
                    temp_sgt.setsLect(temp.getsLect());

                    if(tempAssign.isEmpty()) break;

                    int iHallFound = 0;

                    for (CoupledData heuristicsData : event.getPreferredDays().getHeuristics()){
                        if(tempAssign.isEmpty()) break;
                        if(iHallFound == 1) break;
                        String sDayIteration = heuristicsData.getsDay();

                        for (Hall halls : timetable.getHalls()) {                     //test for each day the availability if not available proceed to assigning toa free slot,if there are available
                            //could add the combinations filter here // add if (hallsFound == 1 ) break;

                            if(tempAssign.isEmpty()) break;
                            if(iHallFound == 1) break;

                            students = randomStudents(tempAssign, halls.getiCapacity());
                            if(tempAssign.size() < halls.getiCapacity()){//change this to tempAssign
                                students = new ArrayList<>(tempAssign);
                            }
                            ArrayList<CoupledData> hours = v_hoursHeuristics_RemainingStudents(students, DSCALE_GLOBAL);

                            ArrayList<Timeslot> notAvailable = notavailableTime_specificDay(students, timetable, temp_sgt);               //ONLY FOR TESTING

                            temp_sgt.setNotAvailableSlots(notAvailable);

                            ArrayList<Timeslot> iTimes = halls.findAvailableSlot_PreferredDay_sgt_remastered(900, 1.0, heuristicsData.getsDay(), event, temp_sgt.getNotAvailableSlots());
                            temp_sgt.setAvailableSlots(iTimes);

                            for( CoupledData coupledData : hours) {

                                if (iHallFound == 1) break;
                                if (tempAssign.isEmpty()) break;

                                int iHourFound = i_prefferedTime_byDay_check(temp_sgt, sDayIteration, coupledData.getiHour(),halls.getsAbbrev());

                                if (iHourFound != 0){

                                    int iFinalCheck = halls.checkAvailability(sDayIteration, iHourFound, 1.0);
                                    if(iFinalCheck == 0 && coupledData.getiHour() == hours.get(hours.size()-1).getiHour()){ break; }
                                    if (iFinalCheck != 0) {

                                        int iAddCode = halls.getiAdditionalCode();
                                        for (int t = 0; t < timetable.getHalls().size(); t++) {
                                            if (timetable.getHalls().get(t).getiAdditionalCode() == iAddCode) {
                                                timetable.getHalls().get(t).setAvToZero(iHourFound, (int) (iHourFound + 1 * 100), sDayIteration);   // ONLY TRIES THE FIRST CHOICE OF HEURISTICS
                                                updateAvailabilitySlotsSGT(temp_sgt, sDayIteration, halls.getsAbbrev(),iHourFound);

                                                for (int f = 0; f < timetable.getWeekTimet().size(); f++) {                 //add to the Day log, for printing purposes + check
                                                    if (timetable.getWeekTimet().get(f).getSname().toLowerCase(Locale.ROOT).equals(sDayIteration.toLowerCase(Locale.ROOT))) {
                                                        timetable.getWeekTimet().get(f).v_assignEvent(iHourFound, 1, halls.getsAbbrev(), temp.getsLect(), "event");
                                                        int iDate = timetable.getWeekTimet().get(f).getiDate();
                                                        int iMonth = timetable.getWeekTimet().get(f).getiMonth();//+1
                                                        int iYear = timetable.getWeekTimet().get(f).getiYear();//+1900
                                                        iHallFound = 1;
                                                        temp_sgt.setDayAssigned(sDayIteration);
                                                        temp_sgt.setsDayOfWeek(sDayIteration);
                                                        temp_sgt.setiHourScheduled(iHourFound);
                                                        temp_sgt.setiDayScheduled(iDate);
                                                        temp_sgt.setiMonthScheduled(iMonth + 1);
                                                        temp_sgt.setiYearScheduled(iYear); // + 1900
                                                        temp_sgt.setsLectureHall(timetable.getHalls().get(t).getsAbbrev());
                                                        temp_sgt.setiSizeOfHall(halls.getiCapacity());
                                                        break;
                                                    }
                                                }
                                            }
                                        }


                                        // change this to the size of the array assigning which is of course == capacity of the hall
                                        for (int my_itr = 0; my_itr < students.size(); my_itr++) {
                                            //increase the number of attending students for this sgt
                                            tempAssign.remove(students.get(my_itr));
                                            temp_sgt.setiNumberOfStudentsAttending(my_itr + 1);
                                            temp_sgt.addToCodesOfStudentsAssigned(students.get(my_itr).getKings_id());
                                            this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(my_itr).getKings_id()).addToCourses(temp_sgt);
                                            this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(my_itr).getKings_id()).increaseAssignedCoursesNumber();
                                            this.ASSIGNED_STUDENTS_GLOBAL.put((students.get(my_itr).getKings_id()), this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(my_itr).getKings_id()));
                                        }

                                        //carry on assigning people until all people are assigned, if there is
                                        //no available spot for the rest of the people/ all of them then
                                        //try at random, and if again, then add to the unsuccessfully assigned lectures

                                        //now remove them from the data so that they are not retrieved again

                                        updateAvailailitySlotsSGT_AllEvents(temp_sgt);
                                        this.ASSIGNED_SGTS_CURRENTWEEK_GLOBAL.add(temp_sgt); //set students to 0 //inside the if

                                    }



                                }
                            }


                        }



                    }



                }


            }//END OF DUPLET
            if(!tempAssign.isEmpty()){
                //add to sgts with no available spot + students who cannot be assigned, might be partially assigned
                for (int my_itr = 0; my_itr < tempAssign.size(); my_itr++) {
                    //increase the number of attending students for this sgt
                    temp_sgt.setiNumberOfStudentsAttending(my_itr + 1);
                    if(this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(tempAssign.get(my_itr).getKings_id()) != null) this.NOT_ASSIGNED_STUDENTS_GLOBAL.put((tempAssign.get(my_itr).getKings_id()), this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(tempAssign.get(my_itr).getKings_id()));
                    else  this.NOT_ASSIGNED_STUDENTS_GLOBAL.put((tempAssign.get(my_itr).getKings_id()), new Student(tempAssign.get(my_itr).getKings_id(), iYearOfStudy));
                }
                this.NOT_ASSIGNED_SGTS_CURRENTWEEK_GLOBAL.add(temp_sgt);
            }

        }



    }





////Inside the asignAlgorithm


            //ONLY FOR TESING =================================================================================================================================

//            ArrayList<DataSetStudents> testing = new ArrayList<>();
//            ArrayList<DataSetStudents> students_cpu = findInDataByDay(tempAssign, event.getsLect() ,"Monday");
//            tempAssign = randomlyRemoveFromArray(tempAssign, 21);
//            int st2_test = 0;
//            for (int st = 0; st < tempAssign.size(); st++) {
//                st2_test = st;
//                tempAssign.get(st).setNumberforCombinations(st);              //gives each datasetstudent object a unique number
////                tempAssign.get(st).setNumberforCombinations(st);              //gives each datasetstudent object a unique number
//            }
//
//            long start = System.currentTimeMillis();
//
//            ArrayList<DataSetStudents[]> result_testing = generate_myGenerate(st2_test, 15, tempAssign );
//
//            long end = System.currentTimeMillis();
//            long result = end - start;
//
//            System.out.println("Time taken : " + result);
//            System.out.println("Going to sleep!!!");
//            try {
//                Thread.sleep(114000);
//                System.exit(0);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }


            //ONLY FOR TESING =================================================================================================================================





//HC AGAIN, algorithm for assigning the sgts

    public void algorithmAssigning_5050filtering_unimplementedFully(Week_Timetable timetable, int iPredefinedIterations, int minNumForTutorials,int maxNumForTutorials,  int iYearOfStudy) throws SQLException, CloneNotSupportedException, ParseException {


        int iLectureAssignedSuccessfully  = 0;
        ArrayList<DataSetStudents> toAssign = getHCData(iYearOfStudy, timetable.getsTableStudents(), timetable.getsTableCoures());
        //I need to pass the students actually I want for the testing, not all of them every time
        ArrayList<DataSetStudents> tempAssign =  new ArrayList<>();         // I need the list of duplets plus all their details for week2s
        ArrayList<Duplet> sgts = new ArrayList<>();

        String courseAbrev = "";

        if(iYearOfStudy == 1){courseAbrev = "4CCS";}
        if(iYearOfStudy == 2){courseAbrev = "5CCS";}
        if(iYearOfStudy == 3){courseAbrev = "6CCS";}



        for(Duplet event : timetable.getSgt()){
            if(event.getsLect().startsWith(courseAbrev)){
                sgts.add(event);
            }
        }

        HashMap<String, ArrayList<Duplet>> sorterOfSGTs = new HashMap<>();

        for(Duplet event : sgts){
            if(event.getsDayOfWeek().equals("Monday")){
                if(sorterOfSGTs.get("Monday") == null){
                    sorterOfSGTs.put("Monday", new ArrayList<>());
                    sorterOfSGTs.get("Monday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Monday").add(event);
                    continue;
                }
            }
            if(event.getsDayOfWeek().equals("Tuesday")){
                if(sorterOfSGTs.get("Tuesday") == null){
                    sorterOfSGTs.put("Tuesday", new ArrayList<>());
                    sorterOfSGTs.get("Tuesday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Tuesday").add(event);
                    continue;
                }
            }
            if(event.getsDayOfWeek().equals("Wednesday")){
                if(sorterOfSGTs.get("Wednesday") == null){
                    sorterOfSGTs.put("Wednesday", new ArrayList<>());
                    sorterOfSGTs.get("Wednesday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Wednesday").add(event);
                    continue;
                }
            }
            if(event.getsDayOfWeek().equals("Thursday")){
                if(sorterOfSGTs.get("Thursday") == null){
                    sorterOfSGTs.put("Thursday", new ArrayList<>());
                    sorterOfSGTs.get("Thursday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Thursday").add(event);
                    continue;
                }
            }
            if(event.getsDayOfWeek().equals("Friday")){
                if(sorterOfSGTs.get("Friday") == null){
                    sorterOfSGTs.put("Friday", new ArrayList<>());
                    sorterOfSGTs.get("Friday").add(event);
                    continue;
                }else{
                    sorterOfSGTs.get("Friday").add(event);
                    continue;
                }
            }
        }

        ArrayList<Duplet> dupletArrayListSorted = new ArrayList<>();
        if(sorterOfSGTs.get("Friday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Friday"));}
        if(sorterOfSGTs.get("Thursday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Thursday"));}
        if(sorterOfSGTs.get("Wednesday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Wednesday"));}
        if(sorterOfSGTs.get("Tuesday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Tuesday"));}
        if(sorterOfSGTs.get("Monday") != null){dupletArrayListSorted.addAll(sorterOfSGTs.get("Monday"));}


        sgts = (ArrayList<Duplet>) dupletArrayListSorted.clone();
        dupletArrayListSorted = null;
        sorterOfSGTs = null;
        int secondaryAdditionalCode = 0;
        for(Duplet event : sgts){ //start assigning each event
            ArrayList<Integer> codesOfLectures = new ArrayList<>();             //I NEED TO FILL THIS ARRAY AS THOSE ARE THE DEPENDENCIES, each event holds the dependencies of the lecture,
                                                                                // currently due to the large number of students and variations, each event holds as dependencies all the other lectures in the same year, so I could use this to check for
            secondaryAdditionalCode++;
            Duplet temp = (Duplet) event.clone();
            SGT temp_sgt = new SGT();
            tempAssign = findInData(toAssign, event.getsLect());                    //those are the students to be assigned





            for(int numIterations = 0; numIterations < iPredefinedIterations; numIterations++) {

                int iHallFound = 0;
                temp_sgt = new SGT();
                temp_sgt.setPreferredDays(event.getPreferredDays());
                temp_sgt.setiCode(temp.getiCode());
                temp_sgt.setiHours(1);
                temp_sgt.setsLect(temp.getsLect());
                secondaryAdditionalCode++;
                temp_sgt.setiAdditionalCode(secondaryAdditionalCode);


                for (CoupledData heuristicsData : event.getPreferredDays().getHeuristics()) {


                    if (tempAssign.size() == 0) break;
                    if (iHallFound == 1) break;                                                 //will beginfrom the start every time a suitable hall is found for the current iteration
                    String sDayIteration = heuristicsData.getsDay();
                    ArrayList<DataSetStudents> students = findInDataByDay(tempAssign, event.getsLect(), sDayIteration);
                    if(students.isEmpty()) continue;

                    if(students.size() < minNumForTutorials) {
                        if(tempAssign.size() < minNumForTutorials) {
                            break;                                             //would be fantastic to have some functionality that calculates if it is better to assign those students to an already existing sgt rather than adding random students, but I haven't implemented one
                        }
                        else{
                            students.addAll(randomStudents(tempAssign, minNumForTutorials - students.size()));
                        }
                    }

                    for (Hall halls : timetable.getHalls()) {                     //test for each day the availability if not available proceed to assigning toa free slot,if there are available

                        if(iHallFound == 1) break;
                        if(students.isEmpty()) break;
                        if(students.isEmpty() && halls.getsAbbrev().equals(timetable.getHalls().get(timetable.getHalls().size() - 1))) break;       //not reachable //add if hall is the last hall and not found then break;
                        if(halls.getiCapacity() < minNumForTutorials) break;
                        if (students.size() > maxNumForTutorials || students.size() > halls.getiCapacity()) {
                                if(students.size() > maxNumForTutorials) {
                                    if(maxNumForTutorials > halls.getiCapacity()){
                                        if(availableForFiltering(students.size(), halls.getiCapacity()) < 31000000){            // < 30 million means if it takes less than 6 minutes to compute, the number of combination rises far too qickly even for longer periods of times to be considered even though they are possible with this algorithm up to over 100! combinations
                                            combinationsResult(students, tempAssign, halls.getiCapacity());
                                        }else{
                                            students = randomlyRemoveFromArray(students, halls.getiCapacity());
                                        }
                                    }
                                    else{
                                        if(availableForFiltering(students.size(), maxNumForTutorials) < 31000000){
                                            combinationsResult(students, tempAssign, maxNumForTutorials);
                                        }else{
                                            students = randomlyRemoveFromArray(students,maxNumForTutorials);
                                        }
                                    }

                                }
                                if( students.size() > halls.getiCapacity() && students.size() < maxNumForTutorials){
                                    if(availableForFiltering(students.size(), halls.getiCapacity()) < 31000000){
                                        combinationsResult(students, tempAssign, halls.getiCapacity());
                                    }else{
                                        students = randomlyRemoveFromArray(students, halls.getiCapacity());
                                    }
                                }
                        }

                            ArrayList<Timeslot> notAvailable = notavailableTime_specificDay(students, timetable, temp_sgt);
                            //ArrayList<Timeslot> notAvailable_onlyLectures = notavailableTime_specificDay_onlyLectures(students, timetable);               //ONLY FOR TESTING

                            temp_sgt.setNotAvailableSlots(notAvailable);

                            ArrayList<Timeslot> iTimes = halls.findAvailableSlot_PreferredDay_sgt_remastered(900, 1.0, heuristicsData.getsDay(), event, temp_sgt.getNotAvailableSlots());

                            //ArrayList<Timeslot> iTimes_Lectures = halls.findAvailableSlot_PreferredDay_sgt_remastered(900, 1.0, heuristicsData.getsDay(), event, notAvailable_onlyLectures);
                            //temp_sgt.getAvailableSlots().addAll(iTimes);

                            temp_sgt.setAvailableSlots(iTimes);
                            temp_sgt.setCodesOfStudentsAssigned( codesFromDataSetStudents(students) );

                            //temp_sgt.setAvailableSlots_noDependencies(iTimes_Lectures);         //only for testing, changes every time the hall is changed, so not very useful

                            ArrayList<CoupledData> times_coupledData = heuristics_sgt_preferredHours_fromPreferences(temp_sgt, DSCALE_GLOBAL, students);
                            for (CoupledData coupledData : times_coupledData) {
                                int iHourFound = i_prefferedTime_byDay_check(temp_sgt, sDayIteration, coupledData.getiHour(), halls.getsAbbrev());
//                                int iHourFound = halls.checkAvailability(sDayIteration, coupledData.getiHour(), 1.0);
                                if(iHallFound == 1) break;

                                if (iHourFound != 0) {
                                    int iFinalCheck = halls.checkAvailability(sDayIteration, iHourFound, 1.0);
                                    if(iFinalCheck == 0 && coupledData.getiHour() == times_coupledData.get(times_coupledData.size() - 1).getiHour() ){}

                                    if (iFinalCheck != 0 && checkStudents(temp_sgt, sDayIteration, 4, timetable) != 0) {

                                        int iAddCode = halls.getiAdditionalCode();
                                        for (int t = 0; t < timetable.getHalls().size(); t++) {
                                            if (timetable.getHalls().get(t).getiAdditionalCode() == iAddCode) {
                                                timetable.getHalls().get(t).setAvToZero(iHourFound, (int) (iHourFound + 1 * 100), sDayIteration);   // ONLY TRIES THE FIRST CHOICE OF HEURISTICS
                                                updateAvailabilitySlotsSGT(temp_sgt, sDayIteration, halls.getsAbbrev(),iHourFound);

                                                    for (int f = 0; f < timetable.getWeekTimet().size(); f++) {                 //add to the Day log, for printing purposes + check
                                                    if (timetable.getWeekTimet().get(f).getSname().toLowerCase(Locale.ROOT).equals(sDayIteration.toLowerCase(Locale.ROOT))) {
                                                        timetable.getWeekTimet().get(f).v_assignEvent(iHourFound, 1, halls.getsAbbrev(), temp.getsLect(), "event");
                                                        int iDate = timetable.getWeekTimet().get(f).getiDate();
                                                        int iMonth = timetable.getWeekTimet().get(f).getiMonth();//+1
                                                        int iYear = timetable.getWeekTimet().get(f).getiYear();//+1900
                                                        iHallFound = 1;
                                                        temp_sgt.setDayAssigned(sDayIteration);//this line is wrong
                                                        temp_sgt.setiHourScheduled(iHourFound);
                                                        temp_sgt.setiDayScheduled(iDate);
                                                        temp_sgt.setiMonthScheduled(iMonth + 1);
                                                        temp_sgt.setiYearScheduled(iYear); // + 1900
                                                        temp_sgt.setsDayOfWeek(sDayIteration);
                                                        temp_sgt.setsLectureHall(timetable.getHalls().get(t).getsAbbrev());
                                                        temp_sgt.setiSizeOfHall(halls.getiCapacity());
                                                        break;
                                                    }
                                                }
                                            }
                                        }


                                        // change this to the size of the array assigning which is of course == capacity of the hall
                                        //the only place where adding to the students' assigned sgts happens
                                        for (int stdItr = 0; stdItr < students.size(); stdItr++) {
                                            //increase the number of attending students for this sgt
                                            tempAssign.remove(students.get(stdItr));
                                            temp_sgt.setiNumberOfStudentsAttending(stdItr + 1);
                                            //temp_sgt.addToCodesOfStudentsAssigned(students.get(stdItr).getKings_id());
                                            this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(stdItr).getKings_id()).addToCourses(temp_sgt);                                 //so now when the sgt updates itself, the update would reflect inside the student's array of sgts
                                            this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(stdItr).getKings_id()).increaseAssignedCoursesNumber();
                                            this.ASSIGNED_STUDENTS_GLOBAL.put((students.get(stdItr).getKings_id()), this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(stdItr).getKings_id()));

                                        }

                                        //carry on assigning people until all people are assigned, if there is
                                        //no available spot for the rest of the people/ all of them then
                                        //try at random, and if again, then add to the unsuccessfully assigned lectures

                                        //now remove them from the data so that they are not retrieved again
                                        updateAvailailitySlotsSGT_AllEvents(temp_sgt);
                                        this.ASSIGNED_SGTS_CURRENTWEEK_GLOBAL.add(temp_sgt);//or a clone, this is inside the first for(!)

                                    }

                                }
                            }


                    }//END OF HALLS
                }//END OF COUPLED DATA
            } // END OF FOR LOOP

            if(!tempAssign.isEmpty()){
                //students whose preferences for day were not satisfiable would fall into this if statement
                //since there are only a number of days are alowed for a sgt, depending on the lecture, algoithm
                //will still assign to those days
                //if we enter this id statement, a hacked up solution is searched for, something that won't leave students unassigned, however I have not allowed a more complex algorithm to assign to already existing sgts

                int iPredefinedIterations2 = 2*iPredefinedIterations;                   //CHANGE THIS LINE OF CODE
                ArrayList<DataSetStudents> students = new ArrayList<>();

                for(int numIterations = 0; numIterations < iPredefinedIterations2; numIterations++) {

                    temp_sgt = new SGT();
                    temp_sgt.setPreferredDays(event.getPreferredDays());
                    temp_sgt.setiCode(temp.getiCode());
                    temp_sgt.setiHours(1);
                    temp_sgt.setsLect(temp.getsLect());
                    secondaryAdditionalCode++;
                    temp_sgt.setiAdditionalCode(secondaryAdditionalCode);

                    if(tempAssign.isEmpty()) break;

                    int iHallFound = 0;

                        for (CoupledData heuristicsData : event.getPreferredDays().getHeuristics()){
                            if(tempAssign.isEmpty()) break;
                            if(iHallFound == 1) break;
                            String sDayIteration = heuristicsData.getsDay();

                            for (Hall halls : timetable.getHalls()) {                     //test for each day the availability if not available proceed to assigning toa free slot,if there are available
                                //could add the combinations filter here // add if (hallsFound == 1 ) break;

                                if(tempAssign.isEmpty()) break;
                                if(iHallFound == 1) break;
                                if( halls.getiCapacity() < minNumForTutorials) break;
                                if( tempAssign.size() < minNumForTutorials ){ break;  //try and add these poor souls to an already existing lecture if possible
                                }
                                else {

                                    if( tempAssign.size() > maxNumForTutorials){
                                        if(maxNumForTutorials <= halls.getiCapacity()){
                                            students = randomStudents(tempAssign, maxNumForTutorials);
                                        }else{
                                            students = randomStudents(tempAssign, halls.getiCapacity());
                                        }
                                    }
                                    else{
                                        if(maxNumForTutorials <= halls.getiCapacity()){
                                            students = randomStudents(tempAssign, tempAssign.size());
                                        }else{
                                            students = randomStudents(tempAssign, halls.getiCapacity());
                                        }

                                    }
                                }

                                ArrayList<CoupledData> hours = v_hoursHeuristics_RemainingStudents(students, DSCALE_GLOBAL);
                                ArrayList<Timeslot> notAvailable = notavailableTime_specificDay(students, timetable, temp_sgt);

                                temp_sgt.setNotAvailableSlots(notAvailable);

                                ArrayList<Timeslot> iTimes = halls.findAvailableSlot_PreferredDay_sgt_remastered(900, 1.0, heuristicsData.getsDay(), event, temp_sgt.getNotAvailableSlots());
                                temp_sgt.setAvailableSlots(iTimes);
                                temp_sgt.setCodesOfStudentsAssigned( codesFromDataSetStudents(students) );

                                    for( CoupledData coupledData : hours) {

                                            if (iHallFound == 1) break;
                                            if (tempAssign.isEmpty()) break;

                                            int iHourFound = i_prefferedTime_byDay_check(temp_sgt, sDayIteration, coupledData.getiHour(),halls.getsAbbrev());

                                            if (iHourFound != 0){

                                                int iFinalCheck = halls.checkAvailability(sDayIteration, iHourFound, 1.0);
                                                if(iFinalCheck == 0 && coupledData.getiHour() == hours.get(hours.size()-1).getiHour()){ break; }
                                                if (iFinalCheck != 0 && checkStudents(temp_sgt, sDayIteration, 4, timetable) != 0) {

                                                    int iAddCode = halls.getiAdditionalCode();
                                                    for (int t = 0; t < timetable.getHalls().size(); t++) {
                                                        if (timetable.getHalls().get(t).getiAdditionalCode() == iAddCode) {
                                                            timetable.getHalls().get(t).setAvToZero(iHourFound, (int) (iHourFound + 1 * 100), sDayIteration);   // ONLY TRIES THE FIRST CHOICE OF HEURISTICS
                                                            updateAvailabilitySlotsSGT(temp_sgt, sDayIteration, halls.getsAbbrev(),iHourFound);

                                                            for (int f = 0; f < timetable.getWeekTimet().size(); f++) {                 //add to the Day log, for printing purposes + check
                                                                if (timetable.getWeekTimet().get(f).getSname().toLowerCase(Locale.ROOT).equals(sDayIteration.toLowerCase(Locale.ROOT))) {
                                                                    timetable.getWeekTimet().get(f).v_assignEvent(iHourFound, 1, halls.getsAbbrev(), temp.getsLect(), "event");
                                                                    int iDate = timetable.getWeekTimet().get(f).getiDate();
                                                                    int iMonth = timetable.getWeekTimet().get(f).getiMonth();//+1
                                                                    int iYear = timetable.getWeekTimet().get(f).getiYear();//+1900
                                                                    iHallFound = 1;
                                                                    temp_sgt.setDayAssigned(sDayIteration);
                                                                    temp_sgt.setsDayOfWeek(sDayIteration);
                                                                    temp_sgt.setiHourScheduled(iHourFound);
                                                                    temp_sgt.setiDayScheduled(iDate);
                                                                    temp_sgt.setiMonthScheduled(iMonth + 1);
                                                                    temp_sgt.setiYearScheduled(iYear); // + 1900
                                                                    temp_sgt.setsLectureHall(timetable.getHalls().get(t).getsAbbrev());
                                                                    temp_sgt.setiSizeOfHall(halls.getiCapacity());
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }


                                                    // change this to the size of the array assigning which is of course == capacity of the hall
                                                    for (int my_itr = 0; my_itr < students.size(); my_itr++) {
                                                        //increase the number of attending students for this sgt
                                                        tempAssign.remove(students.get(my_itr));
                                                        temp_sgt.setiNumberOfStudentsAttending(my_itr + 1);
                                                        //temp_sgt.addToCodesOfStudentsAssigned(students.get(my_itr).getKings_id());
                                                        this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(my_itr).getKings_id()).addToCourses(temp_sgt);                                 //so now when the sgt updates itself, the update would reflect inside the student's array of sgts
                                                        this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(my_itr).getKings_id()).increaseAssignedCoursesNumber();
                                                        this.ASSIGNED_STUDENTS_GLOBAL.put((students.get(my_itr).getKings_id()), this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(students.get(my_itr).getKings_id()));
                                                    }

                                                    //carry on assigning people until all people are assigned, if there is
                                                    //no available spot for the rest of the people/ all of them then
                                                    //try at random, and if again, then add to the unsuccessfully assigned lectures

                                                    //now remove them from the data so that they are not retrieved again

                                                    updateAvailailitySlotsSGT_AllEvents(temp_sgt);
                                                    this.ASSIGNED_SGTS_CURRENTWEEK_GLOBAL.add(temp_sgt); //set students to 0 //inside the if

                                                }



                                            }
                                        }


                                }



                        }



                }


            }
            if(!tempAssign.isEmpty()){
                //add to sgts with no available spot + students who cannot be assigned, might be partially assigned
                for (int my_itr = 0; my_itr < tempAssign.size(); my_itr++) {
                    //increase the number of attending students for this sgt
                    temp_sgt.setiNumberOfStudentsAttending(my_itr + 1);
                    if(this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(tempAssign.get(my_itr).getKings_id()) != null)
                        this.NOT_ASSIGNED_STUDENTS_GLOBAL.put((tempAssign.get(my_itr).getKings_id()), this.STUDENTS_TO_BE_ASSINGED_GLOBAL.get(tempAssign.get(my_itr).getKings_id()));
                    else
                        this.NOT_ASSIGNED_STUDENTS_GLOBAL.put((tempAssign.get(my_itr).getKings_id()), new Student(tempAssign.get(my_itr).getKings_id(), iYearOfStudy));

                }
                this.NOT_ASSIGNED_SGTS_CURRENTWEEK_GLOBAL.add(temp_sgt);
            }

        }//END OF DUPLET



    }




//Initial methods of checking for the availability, inside Hall class



    public int findAvailableSlot_PreferredDay_sgt(int iHourStart, double iDuration, String sPrefDay, Duplet event, ArrayList<Timeslot> unavailable){

        int iCount = 0;
        int iCount2 = 0;
        int iTime = 0;
        int iResult = 0;
        String sDay = "";
        String sPrevDay = "";                               //here actually lies the 930 problem !!!!
        ArrayList<Timeslot> timeslotsAvailable;
        ArrayList<Timeperiod> slotsToUse = new ArrayList<>();

        while(!availability.get(iCount2).getsDay().equals( event.getDayAssigned() )){
            iCount2++;
        }
        for(int i =iCount2; i< availability.size(); i++){
            if(availability.get(i).getsDay().equals( event.getDayAssigned() )){
                if(availability.get(i).getiTime() >= event.getiHourScheduled() && availability.get(i).getiTime() < event.getiHourScheduled() + event.getiHours()*100  /* + 100*n /*hours to put as unavailable after the lecture, for example a break*/){
                    continue;
                }
            }

            slotsToUse.add(availability.get(i));

        }


            for (Timeslot timeslot : unavailable) { // remove all the depending times from the slotsToUse
                for (Timeperiod slotts : slotsToUse) {
                    if (timeslot.getTimePeriod().get(0).getsDay().equals(slotts.getsDay())) {
                        for (int i = 0; i < timeslot.getTimePeriod().size(); i++) {
                            if(timeslot.getTimePeriod().get(i).getiTime() <= slotts.getiTime()) {
                                if (timeslot.getTimePeriod().get(i).getiTime() == slotts.getiTime()) {
                                    slotts.setiAvailable(0);
                                    break;
                                }
                            }
                            else{
                                break;
                            }
                        }
                    }
                }
            }




        for(int i = 0; i < slotsToUse.size(); i++) {
            sDay = slotsToUse.get(i).getsDay();
            if(sDay.equals(sPrefDay)) {

                if (slotsToUse.get(i).getsDay().equals(sPrefDay)) {
                    if (slotsToUse.get(i).getiAvailable() == 1 && slotsToUse.get(i).getiTime() >= iHourStart &&
                            (
                                    (slotsToUse.get(i).getiDate() >= event.getiDayScheduled() && slotsToUse.get(i).getiMonth() >= event.getiMonthScheduled() - 1 && slotsToUse.get(i).getiYear() >= event.getiYearScheduled() && slotsToUse.get(i).getiTime() >= event.getiHourScheduled() + 100))
                            || (slotsToUse.get(i).getiDate() > event.getiDayScheduled() && slotsToUse.get(i).getiMonth() >= event.getiMonthScheduled() - 1 && slotsToUse.get(i).getiYear() >= event.getiYearScheduled())
                    )
                    {
                        iCount++;
                        if (iCount == 1) {
                            iTime = slotsToUse.get(i).getiTime();
                        }

                    } else {
                        iCount = 0;
                        iTime = 0;
                    }

                    if (iCount == (int)(iDuration * 2)) {
                        //spot found
                        //first one available
                        //I need to return the day and the hour corresponding to the hall
                        return iTime;
                    }

                }
            }
            sPrevDay = slotsToUse.get(i).getsDay();
        }
        return iTime;
    }


//one more function initially used, but not any more, inside Hall

    public CoupledData findAvailableSlotLectures_withPreferences(int iHourStart, double iDuration, ArrayList<String> daysToBeUsed,Duplet event){
        int iCount = 0;
        int iTime = 0;
        CoupledData cp = new CoupledData();
        cp.setsDay("");
        cp.setiHour(0);
        String sDay = "";
        String sPrevDay = "";                               //here actually lies the 930 problem !!!!
        ArrayList<Timeperiod> slotsToUse = new ArrayList<>();

        if(event.getPreferredDays() == null){ return cp; }

        for(int i = 0; i < availability.size(); i++){
            int iCounter =0;
            for(int j = 0 ; j < daysToBeUsed.size(); j++){
                if(availability.get(i).getsDay().equals(daysToBeUsed.get(j))){
                    slotsToUse.add(availability.get(i));
                }
            }
        }

        //every lecture depends on other lectures, in order to not overlap them this code prevents the algorithm of assigning to times when dependent lectures appear
        for(int i=0; i < event.getDependentOn().size(); i++){

            Duplet dependent = event.getDependentOn().get(i);
            if(dependent.getiHourScheduled() < 900 && dependent.getsDayOfWeek().isEmpty()){
                continue;
            }

            for(int k = 0; k < slotsToUse.size(); k++){        //this would usually take significant amount of time, maybe consider first sorting the time of the dependents

                if(event.getsDayOfWeek().equals(slotsToUse.get(k).getsDay()) &&
                        slotsToUse.get(k).getiTime() >= event.getDependentOn().get(i).getiHourScheduled() &&        /* disregard the following comment, this is getting the wrong time ;;   if there are slots which are in the time period of the dependent duplets, set them to 0*/
                        slotsToUse.get(k).getiTime() < (event.getDependentOn().get(i).getiHourScheduled()+100*event.getDependentOn().get(i).getiHours())
                ){
                    slotsToUse.get(k).setiAvailable(0);
                }
            }

        }


    if(event.getPreferredDays().getPrefDay().size() != 0) {


        for (int e = 0; e < event.getPreferredDays().getPrefDay().size(); e++) {
            for (int i = 0; i < slotsToUse.size(); i++) {
                if(cp.getiHour()!=0 && !cp.getsDay().isEmpty()){break;}

                if (slotsToUse.get(i).getsDay().equals(event.getPreferredDays().getPrefDay().get(e))) {

                    sDay = slotsToUse.get(i).getsDay();


                    if (sDay.equals(sPrevDay) && slotsToUse.get(i).getiAvailable() == 1 && slotsToUse.get(i).getiTime() >= iHourStart) {
                        iCount++;
                        if (iCount == 1) {
                            iTime = slotsToUse.get(i).getiTime();
                        }

                        if (iCount == (int) (iDuration * 2)) {
                            //spot found
                            //I need to return the day and the hour corresponding to the hall
                            cp.setiHour(iTime);
                            cp.setsDay(slotsToUse.get(i).getsDay());
                            break;//return cp;
                        }
                    } else {
                        iCount = 0;
                        iTime = 0;
                    }
                    ;
                    sPrevDay = slotsToUse.get(i).getsDay();

                }
            }
        }
    }
        return cp;          //end of _withPreferredDays
    }



    public CoupledData findAvailableSlotLectures(int iHourStart, int iDuration, ArrayList<String> daysToBeUsed, Duplet event){
        int iCount = 0;
        int iTime = 0;
        CoupledData cp = new CoupledData();
        String sDay = "";
        String sPrevDay = "";                               //here actually lies the 930 problem !!!!
        ArrayList<Timeperiod> slotsToUse = new ArrayList<>();

        for(int i = 0; i < availability.size(); i++){
            int iCounter =0;
            for(int j = 0 ; j < daysToBeUsed.size(); j++){
                if(availability.get(i).getsDay().equals(daysToBeUsed.get(j))){
                    slotsToUse.add(availability.get(i));
                }
            }
        }

        for(int i=0; i < event.getDependentOn().size(); i++){       //for each dependent

            Duplet dependent = event.getDependentOn().get(i);
            if(dependent.getiHourScheduled() < 900 && dependent.getsDayOfWeek().isEmpty()){
                continue;
            }

                    for(int k = 0; k < slotsToUse.size(); k++){        //this would usually take significant amount of time, maybe consider first sorting the time of the dependents

                        if(event.getsDayOfWeek().equals(slotsToUse.get(k).getsDay()) &&
                                slotsToUse.get(k).getiTime() >= event.getDependentOn().get(i).getiHourScheduled() &&        /* disregard the following comment, this is getting the wrong time ;;   if there are slots which are in the time period of the dependent duplets, set them to 0*/
                                slotsToUse.get(k).getiTime() < (event.getDependentOn().get(i).getiHourScheduled()+100*event.getDependentOn().get(i).getiHours())
                        ){
                            slotsToUse.get(k).setiAvailable(0);
                        }
                    }

        }


        for(int i = 0; i < slotsToUse.size(); i++){


            sDay = slotsToUse.get(i).getsDay();


                if(sDay.equals(sPrevDay) && slotsToUse.get(i).getiAvailable() == 1 && slotsToUse.get(i).getiTime() >= iHourStart){
                    iCount++;
                    if(iCount == 1){
                        iTime = slotsToUse.get(i).getiTime();
                    }

                    if(iCount == (iDuration*2) ){
                        //spot found
                        //I need to return the day and the hour corresponding to the hall
                        cp.setiHour( iTime );
                        cp.setsDay( slotsToUse.get(i).getsDay());
                        break;
                    }
                }
                else { iCount = 0; iTime = 0; };
            sPrevDay = slotsToUse.get(i).getsDay();

        }
        return cp;
    }



    public CoupledData findAvailableSlotTimeline(int iHourStart, int iDuration, Duplet event){
        int iCount = 0;
        int iTime = 0;
        CoupledData cp = new CoupledData();
        String sDay = "";
        String sPrevDay = "";
        ArrayList<Timeperiod> slotsToUse = new ArrayList<>();

        for(int i = 0; i < availability.size(); i++){
            int iCounter =0;
            while(!availability.get(i).getsDay().equals( event.getDayAssigned() ) && availability.get(i).getiTime() >= event.getiHourScheduled() + 100*event.getiHours() ){
                continue;
            }
            slotsToUse.add(availability.get(i));
        }
        //I also need to take into an account the other tutorials assigned so there is no overlapping and the lectures
        for(int i = 0; i < slotsToUse.size(); i++){               //this doesn't account for the timeperiots being in the same day

            sDay = slotsToUse.get(i).getsDay();
            //sPrevDay = availability.get(i).getsDay();

            if(sDay.equals(sPrevDay) && slotsToUse.get(i).getiAvailable() == 1 && slotsToUse.get(i).getiTime() >= iHourStart){
                iCount++;
                if(iCount == 1){
                    iTime = slotsToUse.get(i).getiTime();
                }
            }
            else { iCount = 0; iTime = 0; };

            if(iCount == (iDuration*2) ){
                //spot found
                //I need to return the day and the hour corresponding to the hall
                cp.setiHour( iTime );
                cp.setsDay( slotsToUse.get(i).getsDay());
                break;
            }
            sPrevDay = slotsToUse.get(i).getsDay();
        }
        return cp;
    }
