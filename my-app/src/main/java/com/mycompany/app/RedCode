//OGC from Availability_Bush + same for Availability_Waterloo

//        void v_update_Bush_to_Zero(int itime) throws SQLException {
//            String s=String.valueOf(itime);
//            String sql = "UPDATE CURICULUM.availability_halls_bush_house " +
//                    "     SET available = 0 " +
//                    "     WHERE hour = " + s;
//
//
//            PreparedStatement preparedStmt = connection.prepareStatement(sql);
//            preparedStmt.execute();
//            preparedStmt.close();
//        }
//
//        void v_update_Bush_to_One(int itime) throws SQLException {
//            String s=String.valueOf(itime);
//            String sql = "UPDATE CURICULUM.availability_halls_bush_house " +
//                "     SET available = 1 " +
//                "     WHERE hour = " + s;
//
//
//            PreparedStatement preparedStmt = connection.prepareStatement(sql);
//            preparedStmt.execute();
//            preparedStmt.close();
//        }
//
//        boolean b_checkAvailableAt(int itime) throws SQLException {
//            String s=String.valueOf(itime);
//            Statement stmt = connection.createStatement();
//            String sql = "SELECT available " +
//                    "     FROM curiculum.timeslots " +
//                    "     WHERE  hour = " + s;
//
//
//            ResultSet rs = stmt.executeQuery(sql);
//            stmt.close();
//
//            if(rs.getInt("available") == 1){
//                rs.close();
//                return true;
//            }
//            else{ rs.close(); return  false; }
//
//        }




    //OGC from Greedy Algorithm
//
//    private void vgenerateTableAvailabilityOfHalls()throws SQLException{
//        //1.start by assigning the lectures in the timeslots available from the week days
//        //2.assign the students to the lectures following the simple rules of the hard constraints
//        //3.
//        // find a suitable layout of tutorials and lectures . Only Lectures first. since tutorials are not yet inserted
//        int iCounter = 0;
//        ArrayList<String> mylist = new ArrayList<>();
//        mylist.add("Monday");
//        mylist.add("Tuesday");
//        mylist.add("Wednesday");
//        mylist.add("Thursday");
//        mylist.add("Friday");
//        String sql22 = "SELECT abreviation,hours_twoweeks FROM s_courses WHERE hours_twoweeks != 0";
//        Statement statement = connection.createStatement();
//        ResultSet resSet = statement.executeQuery(sql22);
//        int index = 0;
//        while(resSet.next()){
//            String abrev = resSet.getString("abreviation");
//            int iHours = resSet.getInt("hours_twoweeks")/2;
//            initial.add(new Duplet(abrev,iHours));
//            initial.add(new Duplet(abrev,iHours));
//            System.out.println(initial.get(index));
//            index++;
//            index++;
//        }
//        int sum = 0;
//        for(int i = 0; i < initial.size(); i++){
//            sum += initial.get(i).getiHours();
//        }
//        System.out.println("Sum:" + sum);
//        //create a table of assigned lectures:
//        String sql99 = "DROP TABLE IF EXISTS assigned_lects";
//        String sql33 = "DROP TABLE IF EXISTS halls_availability_tweeks";
//        String sql11 =
//                "CREATE TABLE assigned_lects(" +
//                        "ABBREV VARCHAR(10), " +
//                        "HOURS INT(2), " +
//                        "HALL VARCHAR(30)," +
//                        "DAYTIME INT(4))";
//        String sql88 =
//                "CREATE TABLE halls_availability_tweeks(" +
//                        "AVAILABLE INT(1)," +
//                        "HALL VARCHAR(10)," +
//                        "HOUR INT(2), " +
//                        "DAY VARCHAR(10))";
//        String sql44 = "SELECT AVAILABLE, HALL, HOUR FROM availability_halls_bush_house";
//        String sql55 = "SELECT AVAILABLE, HALL, HOUR FROM availability_halls_waterloo";
//        String sql66 = "INSERT INTO halls_availability_tweeks VALUES( ?,?,?,? )";
//
//
//        statement.executeUpdate(sql99);
//        statement.executeUpdate(sql11);
//        statement.executeUpdate(sql33);
//        statement.executeUpdate(sql88);
//
//        ResultSet rst1 = statement.executeQuery(sql44);
//        PreparedStatement prst = connection.prepareStatement(sql66);
//        while(!mylist.isEmpty()){
//            //iCounter++;
//            while(rst1.next()){
//                prst.setInt(1, rst1.getInt("AVAILABLE"));
//                prst.setString(2, rst1.getString("HALL"));
//                prst.setInt(3, rst1.getInt("HOUR"));
//                prst.setString(4, mylist.get(iCounter));
//                prst.executeUpdate();
//            }
//            //System.out.println("Removed" + mylist.get(iCounter));
//            mylist.remove(iCounter);
//            rst1.beforeFirst();
//        }
//
//    }

    //


/*
    private Double d_TotalHoursOfHallsAvailable_Bush_House(String sStardDate, String sEndDate) throws ParseException, SQLException {

            double dHours = 0.0;
            Date date1 = new SimpleDateFormat("dd-MMM-yyyy").parse(sStardDate);
            Date date2 = new SimpleDateFormat("dd-MMM-yyyy").parse(sEndDate);
            String sql34 = "";
            PreparedStatement prst;
            if(date1.getMonth() != date2.getMonth() && date2.getMonth() - date1.getMonth() == 1){
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? " +
                        " UNION " +
                        " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ? ";
                prst = connection.prepareStatement(sql34);
                prst.setInt(1, date1.getMonth());
                prst.setInt(2, date1.getDate());
                prst.setInt(3, date2.getMonth());
                prst.setInt(4,date2.getDate());
            }
            else {
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? UNION";
                int iCounter = 1;
                int iSecondCounter = 0;

                for (int i = date1.getMonth() + 1; i < date2.getMonth(); i++) {
                    sql34 += " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? UNION ";
                    iSecondCounter++;
                }
                sql34 += " SELECT COUNT(*) FROM two_weeks_availability_halls_bush_house WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ?";


                prst = connection.prepareStatement(sql34);
                prst.setInt(iCounter, date1.getMonth());
                prst.setInt(++iCounter, date1.getDate());
                for (int i = 1; i < iSecondCounter + 1; i++) {
                    prst.setInt(++iCounter, date2.getMonth() - i);
                }
                prst.setInt(++iCounter, date2.getMonth()); //check this
                prst.setInt(++iCounter, date2.getDate());    //check this

            }
            ResultSet rst = prst.executeQuery();
            double dSum = 0.0;
            while (rst.next()){
                dSum += rst.getInt(1);
            }


            return dSum/2;
        }
        private Double d_TotalHoursOfHallsAvailable_Waterloo(String sStardDate, String sEndDate) throws ParseException, SQLException {
            double dHours = 0.0;
            Date date1 = new SimpleDateFormat("dd-MMM-yyyy").parse(sStardDate);
            Date date2 = new SimpleDateFormat("dd-MMM-yyyy").parse(sEndDate);
            String sql34 = "";
            PreparedStatement prst;
            if(date1.getMonth() != date2.getMonth() && date2.getMonth() - date1.getMonth() == 1){
                sql34 = " SELECT * FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? " +
                        " UNION " +
                        " SELECT * FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ? ";
                prst = connection.prepareStatement(sql34);
                prst.setInt(1, date1.getMonth());
                prst.setInt(2, date1.getDate());
                prst.setInt(3, date2.getMonth());
                prst.setInt(4,date2.getDate());
            }
            else {
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? UNION";
                int iCounter = 1;
                int iSecondCounter = 0;

                for (int i = date1.getMonth() + 1; i < date2.getMonth(); i++) {
                    sql34 += " SELECT COUNT(*) FROM two_weeks_availability_waterloo WHERE AVAILABLE = 1 AND MONTH = ? UNION ";
                    iSecondCounter++;
                }
                sql34 += " SELECT COUNT(*) FROM two_weeks_availability_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ?";


                prst = connection.prepareStatement(sql34);
                prst.setInt(iCounter, date1.getMonth());
                prst.setInt(++iCounter, date1.getDate());
                for (int i = 1; i < iSecondCounter + 1; i++) {
                    prst.setInt(++iCounter, date2.getMonth() - i);
                }
                prst.setInt(++iCounter, date2.getMonth()); //check this
                prst.setInt(++iCounter, date2.getDate());    //check this

            }
            ResultSet rst = prst.executeQuery();
            double dSum = 0.0;
            while (rst.next()){
                dSum += rst.getInt(1);
            }


            return dSum/2;
        }
        private Double d_TotalHoursOfHallsAvailable_Waterloo_SpecificHall(String sName, String sStardDate, String sEndDate) throws ParseException, SQLException {
            double dHours = 0.0;
            Date date1 = new SimpleDateFormat("dd-MMM-yyyy").parse(sStardDate);
            Date date2 = new SimpleDateFormat("dd-MMM-yyyy").parse(sEndDate);
            String sql34 = "";
            PreparedStatement prst;
            if(date1.getMonth() != date2.getMonth() && date2.getMonth() - date1.getMonth() == 1){
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? AND HALL = ?" +
                        " UNION " +
                        " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ? AND HALL = ?";
                prst = connection.prepareStatement(sql34);
                prst.setInt(1, date1.getMonth());
                prst.setInt(2, date1.getDate());
                prst.setString(3, sName);
                prst.setInt(4, date2.getMonth());
                prst.setInt(5,date2.getDate());
                prst.setString(6, sName);
            }
            else {
                sql34 = " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE >= ? AND HALL = ? UNION";
                int iCounter = 1;
                int iSecondCounter = 0;

                for (int i = date1.getMonth() + 1; i < date2.getMonth(); i++) {
                    sql34 += " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND HALL = ? UNION ";
                    iSecondCounter++;
                }
                sql34 += " SELECT COUNT(*) FROM two_weeks_availability_halls_waterloo WHERE AVAILABLE = 1 AND MONTH = ? AND DATE <= ? AND HALL = ? ";


                prst = connection.prepareStatement(sql34);
                prst.setInt(iCounter, date1.getMonth());
                prst.setInt(++iCounter, date1.getDate());
                prst.setString(++iCounter, sName);
                for (int i = 1; i < iSecondCounter + 1; i++) {
                    prst.setInt(++iCounter, date2.getMonth() - i);
                    prst.setString(++iCounter, sName);
                }
                prst.setInt(++iCounter, date2.getMonth()); //check this
                prst.setInt(++iCounter, date2.getDate());    //check this
                prst.setString(++iCounter, sName);
            }
            ResultSet rst = prst.executeQuery();
            double dSum = 0.0;
            while (rst.next()){
                dSum += rst.getInt(1);
            }


            return dSum/2;
        }

        private Double d_TotalHoursOfHallsAvailable(String sStardDate, String sEndDate) throws ParseException, SQLException {
            return d_TotalHoursOfHallsAvailable_Bush_House(sStardDate,sEndDate) + d_TotalHoursOfHallsAvailable_Waterloo(sStardDate, sEndDate);
        }
        private int d_AllHallsCapacity() throws  SQLException{
            int iResult = 0;
            String sql99 = "SELECT SUM(CAPACITY) FROM FACILITIES";
            PreparedStatement prst = connection.prepareStatement(sql99);
            ResultSet rst = prst.executeQuery();
            while(rst.next()){
                iResult = rst.getInt(1);
            }
            return iResult;
        }
        private int d_SpicificHallCapacity(String sName) throws  SQLException{
            int iResult = 0;
            String sql99 = "SELECT CAPACITY FROM FACILITIES WHERE inside_code = ?";
            PreparedStatement prst = connection.prepareStatement(sql99);
            prst.setString(1, sName);
            ResultSet rst = prst.executeQuery();
            while(rst.next()){
                iResult = rst.getInt(1);
            }
            return iResult;
        }
        /**/
        private double d_capacityPerHour_Waterloo_SpecificHall(String sName,String sStartDate,String sEndDate) throws SQLException, ParseException {
            double iResult = d_SpicificHallCapacity(sName);
            double sHours = d_TotalHoursOfHallsAvailable_Waterloo_SpecificHall(sName, sStartDate, sEndDate);

            return sHours*iResult / 55;
        }
*/



//from inserter_lectures_assigned method finalTable
while(iCounter != 80){
            iCounter++;
            //find the attendance where values are too low = below the min
            if(initial_values.size() != 0) {
                if (initial_values_attendance.get(0) < min) {
                    for (int j = 0; j < values.size(); j++) {
                        //too few
                        if (values.get(j).getiAttending() > min && values.get(j).getiAttending() + initial_values_attendance.get(0) < max) {
                            //suitable solution found
                            iStudentsReassigned += initial_values_attendance.get(0);
                            values.set(j, new TwoInts(values.get(j).getiCode(), values.get(j).getiAttending() + initial_values_attendance.get(0)));
//something I noticed about this method is that it is going to pick the first available course every time,
                            initial_values_attendance.remove(0);
                            initial_values.remove(0);
                            iAssigned = 1;
                            String sql77 = "UPDATE students_lectures SET lecture_code = " + Integer.toString(values.get(j).getiCode()) + " WHERE lecture_code = " + Integer.toString(initial_values.get(0));
                            Statement statement2 = connection.createStatement();
                            statement2.executeUpdate(sql77);
                            break; // before breaking this would need updating
                        } else {
                            //no suitable courses found: how do we proceed?? -> assign to the next available course in the current list

                        }
                    }
                    if (iAssigned == 0) {
                        initial_values_attendance.add(initial_values_attendance.get(0));
                        initial_values_attendance.remove(0);
                        initial_values.add(initial_values.get(0));
                        initial_values.remove(0);
                    }
                    iAssigned = 0;
                }
            }
            else if (initial_values.size() != 0 && initial_values_attendance.get(0) > max){

            }
            else{
                if(initial_values.size() != 0 && initial_values_attendance.get(0) < min ){
                    continue;
                }else if(initial_values.size() != 0 && initial_values_attendance.get(0) > max ){
                    //add to values array

                }
                else {
                    continue;
                }
            }

        }
////


///GREEDY ALGORITHM:


    public int generateGreedySolution(String sTable,String sTableStudents, int min, int max, ArrayList<String> preferreddays) throws SQLException, ParseException, CloneNotSupportedException, IOException {


        this.sCoursesTable = sTable;
        this.sStudentsTable = sTableStudents;
        this.iLocalMin = min;
        this.iLocalMax = max;
        this.prefdDays= preferreddays;

        Week_Timetable week_timetableont = myTimetable(7);

        ArrayList <Duplet> myarr = lecturesToBeAssigned2( getTwoInts() ,1, sTable);  //this ARRAY contains all the info for the lectures
        ArrayList <Duplet> weekOne = new ArrayList<>();
        ArrayList <Duplet> weekTwo = new ArrayList<>();

        for (int i = 0; i < myarr.size(); i++) {
                myarr.get(i).setPreferredDays(new PreferredDays(preferreddays));
        }

/*            for (int i = 0; i < myarr.size(); i++) {
//                myarr.get(i).setPreferredDays(o_getPreferencesStudents(myarr.get(i).getsLect(), 1, 5));
//                myarr.get(i).setsTeachersPreference(s_getLecturersChoice(myarr.get(i).getsLect()));
//            }
*/
        Collections.sort(myarr);                        //sort my array to start searching for the lectures with least students (asc order)

        for(int i = 0; i < myarr.size(); i++){
            if(i % 2 == 0){ weekOne.add(myarr.get(i));}
            else{weekTwo.add(myarr.get(i));}
        }


         //week_timetableont.setLectures(myarr); //ONLY FOR TESTING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         week_timetableont.setLectures(weekOne);

        weekOne = setConstraints(weekOne);
        weekTwo = setConstraints(weekTwo);              //I could clone the weekOne here instead
        //myarr = setConstraints(myarr); //ONLY FOR TESTING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        //addDaysToLastMostRecentDay(7);
        ArrayList<Hall> halls = hallsAvailability_forlectures(week_timetableont.getsStartDay(), week_timetableont.getsEndDay());//will have to change this to take the parameters of the week, suttle change
        week_timetableont.setHalls(halls);

        //Collections.sort(halls);


        //assign lectures to Halls here :
        // i need to find a way to make the algorithm tell if there is no solution
        // checkAtEachStepTheConstraints
        //
        //week_timetableont.getLectures().forEach((n) -> System.out.print(n));

        int iCounter = 0;
        while (iCounter != 2000){

             int iStudents = 0;
            if(week_timetableont.getLectures().size() != 0 && week_timetableont.getHalls().size() != 0) {
                iStudents = week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending();
            }
            else{ iCounter++; continue;}

            week_timetableont = recursion_for_lectures(week_timetableont,week_timetableont.getHalls(), week_timetableont.getLectures(),week_timetableont.getAssignedLectures(),
                    week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending() ,week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending(),
                    1,0, 1);
            iCounter++;

            }


        ///lectures correspond to the tutorials with the exception that tutorials are shorter
            //week_timetableont.updateDependentOnTutorials();
        ///

        //week_timetableont.getHalls().forEach((n)->System.out.println(n));
        System.out.println("Not Assigned Lectures:");
        System.out.println(week_timetableont.getLectures());

        for(int i = 0; i < week_timetableont.getWeekTimet().size();i++){
            Collections.sort(week_timetableont.getWeekTimet().get(i).getoDslot2());
        }
        week_timetableont.v_print();

        this.week_timetable_ont = week_timetableont;


//        putInTableAssigned(week_timetableont.getAssignedLectures(), 0);
       // generateTimeTables_firstYear(schedule, sTableStudents);


            if(week_timetableont.getLectures().size() == 0 ){
                // solution found
                return 1;
            }
            else{
                return 0;


                //opt for running the algorithm again, maybe a bit differently or choose to run another algorithm
            }

        /**/


    }



    public int generateGreedySolution2(String sTable, String sTableStudents, int min, int max, ArrayList<String> preferreddays, Week_Timetable week_timetableont) throws SQLException, ParseException, CloneNotSupportedException, IOException {


        ArrayList<Hall> halls = hallsAvailability_forlectures(week_timetableont.getsStartDay(), week_timetableont.getsEndDay());
        //Collections.sort(halls);
        //week_timetableont.setHalls(halls);
        for (int i = 0; i < week_timetableont.getLectures().size(); i++) {
            ArrayList<String> prefs =  new ArrayList<>();
            if(!week_timetableont.getLectures().get(i).getsDayOfWeek().isEmpty()) {
                prefs.add(week_timetableont.getLectures().get(i).getsDayOfWeek());
                week_timetableont.getLectures().get(i).setPreferredDays(new PreferredDays(prefs));
            }
            else{
                week_timetableont.getLectures().get(i).setPreferredDays(new PreferredDays(preferreddays));
            }
        }

        int iCounter = 0;
        while (iCounter != 2000){

            int iStudents = 0;
            if(week_timetableont.getLectures().size() != 0 && week_timetableont.getHalls().size() != 0) {
                iStudents = week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending();
            }
            else{ iCounter++; continue;}

            week_timetableont = recursion_for_lectures(week_timetableont,week_timetableont.getHalls(), week_timetableont.getLectures(),week_timetableont.getAssignedLectures(),
                    week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending() ,week_timetableont.getLectures().get(0).getiNumberOfStudentsAttending(),
                    1,0, 1);
            iCounter++;

        }

        System.out.println("Not Assigned Lectures:");
        System.out.println(week_timetableont.getLectures());

        for(int i = 0; i < week_timetableont.getWeekTimet().size();i++){
            Collections.sort(week_timetableont.getWeekTimet().get(i).getoDslot2());
        }
        week_timetableont.v_print();

        this.week_timetable_spare = week_timetableont;

        if(week_timetableont.getLectures().size() == 0 ){
            return 1;
        }
        else{
            return 0;
        }

        /**/


    }



///////////


//HC algorithm:


                            for(int iHourIterator = 0; iHourIterator < hours.size(); iHourIterator++) {
                                if (!tempAssign.isEmpty() && hours.get(iHourIterator).getiHour() == coupledData.getiHour()) { students.addAll( findInDataByHour(tempAssign, hours.get(iHourIterator).getiHour() )); }
                            }
                            if(students.size() >= halls.getiCapacity()/2){
                                if(tempAssign.size() - students.size() <= halls.getiCapacity()/2){
                                    students = (ArrayList<DataSetStudents>) tempAssign.clone();
                                }
                                else{
                                    if(students.size() > halls.getiCapacity()){
                                        students = randomlyRemoveFromArray(students,halls.getiCapacity());
                                    }
                                }
                            }else{
                                if(students.isEmpty()){
                                    for(int iHourIterator = 0; iHourIterator < hours.size(); iHourIterator++) {
                                        if (!tempAssign.isEmpty()) {
                                            if(students.size() < halls.getiCapacity()/2) students.addAll(findInDataByHour(tempAssign, hours.get(iHourIterator).getiHour()));
                                        }
                                        if (students.size() >= halls.getiCapacity() / 2) {
                                            if (tempAssign.size() - students.size() <= halls.getiCapacity()) {
                                                students = (ArrayList<DataSetStudents>) tempAssign.clone();
                                                break;
                                            }
                                        }
                                    }
                                    if(tempAssign.size() - students.size() <= halls.getiCapacity()/2){
                                        students = (ArrayList<DataSetStudents>) tempAssign.clone();
                                    }
                                }
                                else{
                                    for(int iHourIterator = 0; iHourIterator < hours.size(); iHourIterator++) {
                                        // if (!tempAssign.isEmpty()) { students.addAll( findInDataByHour(tempAssign, hours.get(iHourIterator).getiHour() )); }
                                    }
                                }

                            }
/// END HC


///APP main:

HillClimbing hillClimbing = new HillClimbing(connection);
        hillClimbing.getGrdAlg().setTwoInts(generator.getLectureEvents());
        hillClimbing.getGrdAlg().generateGreedySolution_TwoWeeks("courses", "students", 5, 21,days, "", 0);
        hillClimbing.setTIMETABLEONT_GLOBAL(hillClimbing.getGrdAlg().getWeek_timetable_ont());
        hillClimbing.setTIMETABLETWO_GLOBAL(hillClimbing.getGrdAlg().getWeek_timetable_spare());
        hillClimbing.generateHCSolution(0.9, 3, 5);


//        List<int[]> combinations = generate(29, 20);
//        for (int[] combination : combinations) {
//            //System.out.println(Arrays.toString(combination));
//        }
//        System.out.printf("generated %d combinations of %d items from %d ", combinations.size(), 2, 5);

    private static void helper(List<int[]> combinations, int data[], int start, int end, int index) {
        if (index == data.length) {
            int[] combination = data.clone();
            combinations.add(combination);
        } else if (start <= end) {
            data[index] = start;
            helper(combinations, data, start + 1, end, index + 1);
            helper(combinations, data, start + 1, end, index);
        }
    }


    public static List<int[]> generate(int n, int r) {
        List<int[]> combinations = new ArrayList<>();
        helper(combinations, new int[r], 0, n-1, 0);
        return combinations;
    }
